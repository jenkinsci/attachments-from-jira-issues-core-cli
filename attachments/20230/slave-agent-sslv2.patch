diff --git a/core/src/main/java/hudson/TcpSlaveAgentListener.java b/core/src/main/java/hudson/TcpSlaveAgentListener.java
index 6910f0f..dc051b6 100644
--- a/core/src/main/java/hudson/TcpSlaveAgentListener.java
+++ b/core/src/main/java/hudson/TcpSlaveAgentListener.java
@@ -56,6 +56,9 @@ import java.util.concurrent.TimeoutException;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import javax.net.ServerSocketFactory;
+import javax.net.ssl.SSLServerSocketFactory;
+
 /**
  * Listens to incoming TCP connections from JNLP slave agents and CLI.
  *
@@ -89,21 +92,41 @@ public final class TcpSlaveAgentListener extends Thread {
     private volatile boolean shuttingDown;
 
     public final int configuredPort;
-
+    
+    public final boolean enableSSL;
+    
     /**
      * @param port
      *      Use 0 to choose a random port.
      */
     public TcpSlaveAgentListener(int port) throws IOException {
+        this(port, false);
+    }
+    
+    /**
+     * @param port
+     * @param enableSSL
+     *      Use 0 to choose a random port.
+     */
+    public TcpSlaveAgentListener(int port, boolean enableSSL) throws IOException {
         super("TCP slave agent listener port="+port);
         try {
-            serverSocket = new ServerSocket(port);
+        	if (enableSSL) {
+        		ServerSocketFactory ssocketFactory = SSLServerSocketFactory.getDefault();
+        		serverSocket = ssocketFactory.createServerSocket(port);
+        	} else {
+        		serverSocket = new ServerSocket(port);
+        	}
         } catch (BindException e) {
             throw (BindException)new BindException("Failed to listen on port "+port+" because it's already in use.").initCause(e);
         }
         this.configuredPort = port;
-
-        LOGGER.info("JNLP slave agent listener started on TCP port "+getPort());
+        this.enableSSL = enableSSL;
+        
+        if(enableSSL)
+        	LOGGER.info("JNLP SSL slave agent listener started on TCP port "+getPort());
+        else
+        	LOGGER.info("JNLP slave agent listener started on TCP port "+getPort());
 
         start();
     }
diff --git a/core/src/main/java/hudson/model/Hudson.java b/core/src/main/java/hudson/model/Hudson.java
index d0ef469..5394f78 100644
--- a/core/src/main/java/hudson/model/Hudson.java
+++ b/core/src/main/java/hudson/model/Hudson.java
@@ -477,6 +477,11 @@ public final class Hudson extends Node implements ItemGroup<TopLevelItem>, Stapl
     private int slaveAgentPort =0;
 
     /**
+     * Enable SSL for slave agent connections
+     */
+    private boolean enableSlaveAgentSSL =false;
+    
+    /**
      * Whitespace-separated labels assigned to the master as a {@link Node}.
      */
     private String label="";
@@ -674,7 +679,7 @@ public final class Hudson extends Node implements ItemGroup<TopLevelItem>, Stapl
 
             if(slaveAgentPort!=-1) {
                 try {
-                    tcpSlaveAgentListener = new TcpSlaveAgentListener(slaveAgentPort);
+                    tcpSlaveAgentListener = new TcpSlaveAgentListener(slaveAgentPort, enableSlaveAgentSSL);
                 } catch (BindException e) {
                     new AdministrativeError(getClass().getName()+".tcpBind",
                             "Failed to listen to incoming slave connection",
@@ -1872,6 +1877,14 @@ public final class Hudson extends Node implements ItemGroup<TopLevelItem>, Stapl
     public boolean isUseCrumbs() {
         return crumbIssuer!=null;
     }
+    
+    /**
+     * If true, enable SSL for slave agent connections
+     */
+    @Exported
+    public boolean isEnableSlaveAgentSSL() {
+        return enableSlaveAgentSSL;
+    }
 
     /**
      * Returns the constant that captures the three basic security modes
@@ -2473,16 +2486,23 @@ public final class Hudson extends Node implements ItemGroup<TopLevelItem>, Stapl
                     }
                 }
 
+                if (isUseSecurity() && req.getParameter("enableSlaveAgentSSL")!=null) {
+                	enableSlaveAgentSSL = true;
+                } else {
+                	enableSlaveAgentSSL = false;
+                }
+                
                 // relaunch the agent
                 if(tcpSlaveAgentListener==null) {
                     if(slaveAgentPort!=-1)
-                        tcpSlaveAgentListener = new TcpSlaveAgentListener(slaveAgentPort);
+                        tcpSlaveAgentListener = new TcpSlaveAgentListener(slaveAgentPort, enableSlaveAgentSSL);
                 } else {
-                    if(tcpSlaveAgentListener.configuredPort!=slaveAgentPort) {
+                    if(tcpSlaveAgentListener.configuredPort!=slaveAgentPort ||
+                       tcpSlaveAgentListener.enableSSL!=enableSlaveAgentSSL) {
                         tcpSlaveAgentListener.shutdown();
                         tcpSlaveAgentListener = null;
                         if(slaveAgentPort!=-1)
-                            tcpSlaveAgentListener = new TcpSlaveAgentListener(slaveAgentPort);
+                            tcpSlaveAgentListener = new TcpSlaveAgentListener(slaveAgentPort, enableSlaveAgentSSL);
                     }
                 }
             }
diff --git a/core/src/main/resources/hudson/model/Hudson/configure.jelly b/core/src/main/resources/hudson/model/Hudson/configure.jelly
index 8774529..5592782 100644
--- a/core/src/main/resources/hudson/model/Hudson/configure.jelly
+++ b/core/src/main/resources/hudson/model/Hudson/configure.jelly
@@ -121,6 +121,12 @@ THE SOFTWARE.
           <label for="sat.disabled">${%Disable}</label>
         </f:entry>
 
+        <f:optionalBlock name="enableSlaveAgentSSL" checked="${it.enableSlaveAgentSSL}"
+                         title="${%Use SSL for JNLP slave agent connections}"
+                         help="/help/system-config/master-slave/slave-agent-ssl.html" />
+
+
+
         <f:dropdownDescriptorSelector title="${%Markup Formatter}" field="markupFormatter" />
 
         <f:entry title="${%Access Control}">
diff --git a/core/src/main/resources/hudson/slaves/SlaveComputer/slave-agent.jnlp.jelly b/core/src/main/resources/hudson/slaves/SlaveComputer/slave-agent.jnlp.jelly
index 6bcafe7..ca6462d 100644
--- a/core/src/main/resources/hudson/slaves/SlaveComputer/slave-agent.jnlp.jelly
+++ b/core/src/main/resources/hudson/slaves/SlaveComputer/slave-agent.jnlp.jelly
@@ -83,6 +83,10 @@ THE SOFTWARE.
           -->
           <argument>-url</argument>
           <argument>${app.rootUrlFromRequest}</argument>
+        </j:if>    
+        <j:if test="${app.enableSlaveAgentSSL != false}">
+          <argument>-enableSSL</argument>
+          <argument>true</argument>
         </j:if>
       </application-desc>
     </jnlp>
diff --git a/remoting/src/main/java/hudson/remoting/Engine.java b/remoting/src/main/java/hudson/remoting/Engine.java
index 658d656..25ed451 100644
--- a/remoting/src/main/java/hudson/remoting/Engine.java
+++ b/remoting/src/main/java/hudson/remoting/Engine.java
@@ -23,6 +23,8 @@
  */
 package hudson.remoting;
 
+import hudson.remoting.Launcher.NoCheckTrustManager;
+
 import java.io.BufferedInputStream;
 import java.io.BufferedOutputStream;
 import java.io.DataOutputStream;
@@ -32,6 +34,9 @@ import java.io.ByteArrayOutputStream;
 import java.net.HttpURLConnection;
 import java.net.Socket;
 import java.net.URL;
+import java.security.GeneralSecurityException;
+import java.security.KeyManagementException;
+import java.security.NoSuchAlgorithmException;
 import java.util.Properties;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -39,6 +44,12 @@ import java.util.concurrent.ThreadFactory;
 import java.util.List;
 import java.util.Collections;
 import java.util.logging.Logger;
+
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+
 import static java.util.logging.Level.SEVERE;
 
 /**
@@ -89,6 +100,10 @@ public class Engine extends Thread {
      * See Main#tunnel in the jnlp-agent module for the details.
      */
     private String tunnel;
+    
+    private boolean enableSSL=false;
+    
+    private SSLContext context;
 
     private boolean noReconnect;
 
@@ -115,6 +130,14 @@ public class Engine extends Thread {
     public void setTunnel(String tunnel) {
         this.tunnel = tunnel;
     }
+    
+    public void setEnableSSL(boolean enableSSL) {
+    	this.enableSSL = enableSSL;
+    }
+    
+    public void setSSLContext(SSLContext context) {
+    	this.context = context;
+    }
 
     public void setCredentials(String creds) {
         this.credentials = creds;
@@ -206,7 +229,7 @@ public class Engine extends Thread {
                 ByteArrayOutputStream o = new ByteArrayOutputStream();
                 props.store(o, null);
                 dos.writeUTF(o.toString("UTF-8"));
-
+                
                 String greeting = readLine(in);
                 if (greeting.startsWith("Unknown protocol")) {
                     LOGGER.info("The server didn't understand the v2 handshake. Falling back to v1 handshake");
@@ -315,9 +338,23 @@ public class Engine extends Thread {
         int retry = 1;
         while(true) {
             try {
-                Socket s = new Socket(host, Integer.parseInt(port));
-                s.setTcpNoDelay(true); // we'll do buffering by ourselves
+                Socket s;
+                
+                if(this.enableSSL) {
+                    // secure
+                    LOGGER.info("Creating secure socket");
+                    SSLSocketFactory sslsocketfactory;
+                    if(this.context!=null)
+                        sslsocketfactory = context.getSocketFactory();
+                    else
+                        sslsocketfactory = ((SSLSocketFactory) SSLSocketFactory.getDefault());
+                    s = sslsocketfactory.createSocket(host, Integer.parseInt(port));
+                    ((SSLSocket) s).startHandshake();
+                }else{
+                    s = new Socket(host, Integer.parseInt(port));
+                }
 
+                s.setTcpNoDelay(true); // we'll do buffering by ourselves
                 // set read time out to avoid infinite hang. the time out should be long enough so as not
                 // to interfere with normal operation. the main purpose of this is that when the other peer dies
                 // abruptly, we shouldn't hang forever, and at some point we should notice that the connection
@@ -325,6 +362,11 @@ public class Engine extends Thread {
                 s.setSoTimeout(30*60*1000); // 30 mins. See PingThread for the ping interval
                 return s;
             } catch (IOException e) {
+            	if(e.getMessage().contains("PKIX path building failed")) {
+                    IOException x = new IOException("Failed to validate a server certificate. If you are using a self-signed certificate, you can use the -noCertificateCheck option to bypass this check.");
+                    x.initCause(e);
+                    throw x;
+            	}
                 if(retry++>10)
                     throw (IOException)new IOException("Failed to connect to "+host+':'+port).initCause(e);
                 Thread.sleep(1000*10);
diff --git a/remoting/src/main/java/hudson/remoting/Launcher.java b/remoting/src/main/java/hudson/remoting/Launcher.java
index b56009d..e68bd5e 100644
--- a/remoting/src/main/java/hudson/remoting/Launcher.java
+++ b/remoting/src/main/java/hudson/remoting/Launcher.java
@@ -146,7 +146,7 @@ public class Launcher {
      */
     @Option(name="-noCertificateCheck")
     public void setNoCertificateCheck(boolean _) throws NoSuchAlgorithmException, KeyManagementException {
-        System.out.println("Skipping HTTPS certificate checks altoghether. Note that this is not secure at all.");
+        System.out.println("Skipping certificate checks altoghether. Note that this is not secure at all.");
         SSLContext context = SSLContext.getInstance("TLS");
         context.init(null, new TrustManager[]{new NoCheckTrustManager()}, new java.security.SecureRandom());
         HttpsURLConnection.setDefaultSSLSocketFactory(context.getSocketFactory());
@@ -156,6 +156,7 @@ public class Launcher {
                 return true;
             }
         });
+        hudson.remoting.jnlp.Main.context = context;
     }
 
     public static void main(String... args) throws Exception {
@@ -422,7 +423,7 @@ public class Launcher {
     /**
      * {@link X509TrustManager} that performs no check at all.
      */
-    private static class NoCheckTrustManager implements X509TrustManager {
+    protected static class NoCheckTrustManager implements X509TrustManager {
         public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {
         }
 
diff --git a/remoting/src/main/java/hudson/remoting/jnlp/Main.java b/remoting/src/main/java/hudson/remoting/jnlp/Main.java
index b80638f..de3e882 100644
--- a/remoting/src/main/java/hudson/remoting/jnlp/Main.java
+++ b/remoting/src/main/java/hudson/remoting/jnlp/Main.java
@@ -36,6 +36,8 @@ import java.util.ArrayList;
 import java.net.URL;
 import java.io.IOException;
 
+import javax.net.ssl.SSLContext;
+
 import hudson.remoting.Engine;
 import hudson.remoting.EngineListener;
 
@@ -71,6 +73,11 @@ public class Main {
     @Option(name="-noreconnect",
             usage="If the connection ends, don't retry and just exit.")
     public boolean noReconnect = false;
+    
+    @Option(name="-enableSSL",usage="Use SSL connection to master")
+    public boolean enableSSL = false;
+
+    public static SSLContext context;
 
     /**
      * 4 mandatory parameters.
@@ -107,7 +114,7 @@ public class Main {
         Main m = new Main();
         CmdLineParser p = new CmdLineParser(m);
         p.parseArgument(args);
-        if(m.args.size()!=2)
+        if(m.args.size()!=2 && m.args.size()!=3)
             throw new CmdLineException("two arguments required, but got "+m.args);
         if(m.urls.isEmpty())
             throw new CmdLineException("At least one -url option is required.");
@@ -123,6 +130,9 @@ public class Main {
             engine.setTunnel(tunnel);
         if(credentials!=null)
             engine.setCredentials(credentials);
+        if(context!=null)
+        	engine.setSSLContext(context);
+        engine.setEnableSSL(enableSSL);
         engine.setNoReconnect(noReconnect);
         engine.start();
         engine.join();
